RP2040 Pin allocation
GPIO  Block     Use
  0   UART0     Main UART to Pi TX
  1   UART0     Main UART to Pi RX
  2   UART0     Main UART to Pi CTS
  3   UART0     Main UART to Pi RTS
  4   PIO       Port2 RX
  5   PIO       Port2 TX
  6   PIO       Port2 RS485TXRX
  7   PIO       Port2 RS485TXEnable
  8   IIC0      SDA0 PORTS 1,2 and Accelerometer
  9   IIC0      SCL0
 10   PIO       Port1 RX
 11   PIO       Port1 TX
 12   PIO       Port1 RS485TXRX
 13   PIO       Port1 RS485TXEnable
 14   GPIO      LED0
 15   GPIO      LED1
 16   GPIO/IRQ  PORT_FAULT ( +3.3v to the ports overloaded) needs pullup
 17   GPIO      PORT_CE ( +3.3v to the ports enable pin)
 18   IIC1      SDA1 Ports 3,4
 19   IIC1      SCL1
 20   PIO       Port4 RX
 21   PIO       Port4 TX
 22   PIO       Port4 RS485TXRX
 23   PIO       Port4 RS485TXEnable
 24   PIO       Port3 RX
 25   PIO       Port3 TX
 26   PIO       Port3 RS485TXRX
 27   PIO       Port3 RS485TXEnable
 28   GPIO/IRQ  nFL (Motor fault) needs pull up
 29   ADC       ADC_VIN = (vin*10/(10+47))

To get Picoprobe to work with udev rule some combination of the following
works.

root@ear:/etc/udev/rules.d# cat 99-picoprobe.rules
# Picoprobe
# ATTRS{idVendor}=="2E8A", ATTRS{idProduct}=="0004", MODE="0666", OWNER="mo", GROUP="mo"
# ATTRS{idVendor}=="2e8a", ATTRS{idProduct}=="0004", MODE="660", GROUP="plugdev", TAG+="uaccess"
ATTRS{idVendor}=="2e8a", ATTRS{idProduct}=="0004", MODE="660", GROUP="plugdev"

root@ear:/etc/udev/rules.d# /etc/init.d/udev restart
root@ear:/etc/udev/rules.d# udevadm control --reload

Built openocd branch with modified Makefile:
  prefix = /home/mo/tempd/pico/openocd/usr/local
instead of
  prefix = /usr/local

Then can make install as non-root and not write over other modified version
of openocd we already have in /usr/local.

Now (as non-root) can do

/home/mo/tempd/pico/openocd/usr/local/bin/openocd -f /home/mo/tempd/pico/openocd/usr/local/share/openocd/scripts/interface/picoprobe.cfg -f /home/mo/tempd/pico/openocd/usr/local/share/openocd/scripts/target/rp2040.cfg -s tcl

For bootloader:
  Standard linker scripts are in pico-sdk/src/rp2_common/pico_standard_link
  Looks like we can override using a CMAKEism. From pico-sdk/src/rp2_common/pico_standard_link/CMakeLists.txt :
    # LINKER script will be PICO_TARGET_LINKER_SCRIPT if set on target, or ${CMAKE_CURRENT_LIST_DIR}/memmap_foo.ld

export PICO_SDK_PATH=/home/mo/tempd/pico/pico-sdk/


TODO
Fix GPIO drive strengths
Test ID margins
Think about PID control variable from combi mode, alignment problems in device_varfrommode
Make <selvar> just have values 0, 1, 2, 3 (i.e., only signed char/short/int plus float)

I²C commands:

Initialisation :

 # Addr Data Function
 1 0x5C 0x20 Set PWM0 Period CLK to OSC1 Flex-Div
 2 0x5D 0x03 Set OSC1 Flex-Div to 4
 3 0x9D 0x0E Set 2-bit LUT2 Logic to OR
 4 0x19 0x7A Connection 2-bit LUT2 IN1 to I2C OUT7  Connection 2-bit LUT2 IN0 to PWM0 OUT+
 5 0x1A 0x06
 6 0x09 0x03 Connection HV OUT CTRL0 EN Input to 2-bit LUT2 OUT
 7 0x0C 0x03 Connection HV OUT CTRL1 EN Input to 2-bit LUT2 OUT
 8 0x3C 0x16 Connection PWM0 PWR DOWN Input to 3-bit LUT9 OUT
 9 0xB6 0x09 Set PWM0 to flex-Div clock
10 0x4C 0x70 Clear fault flags
11 0x4C 0x7F Enable fault flags

For changing Duty Cycle:

 # Address, hex Data, hex Function
 1 0xA1 0x00 to 0xFF Set PWM0 Initial Duty Cycle value [7:0]. Default: 0x00
 2 0xA2 0x01 Set I2C trigger for PWM0 to Update duty cycle value

The your using the old 10bit design with the period reduce by a quarter (
0x86, 0x3f write ) to give 8 bits

so in port init add the follow I2c write address 0x59 = 0x2A
