RP2040 Pin allocation
GPIO  Block     Use
  0   UART0     Main UART to Pi TX
  1   UART0     Main UART to Pi RX
  2   UART0     Main UART to Pi CTS
  3   UART0     Main UART to Pi RTS
  4   PIO       Port2 RX
  5   PIO       Port2 TX
  6   PIO       Port2 RS485TXRX
  7   PIO       Port2 RS485TXEnable
  8   IIC0      SDA0 PORTS 1,2 and Accelerometer
  9   IIC0      SCL0
 10   PIO       Port1 RX
 11   PIO       Port1 TX
 12   PIO       Port1 RS485TXRX
 13   PIO       Port1 RS485TXEnable
 14   GPIO      LED0
 15   GPIO      LED1
 16   GPIO/IRQ  PORT_FAULT ( +3.3v to the ports overloaded) needs pullup
 17   GPIO      PORT_CE ( +3.3v to the ports enable pin)
 18   IIC1      SDA1 Ports 3,4
 19   IIC1      SCL1
 20   PIO       Port4 RX
 21   PIO       Port4 TX
 22   PIO       Port4 RS485TXRX
 23   PIO       Port4 RS485TXEnable
 24   PIO       Port3 RX
 25   PIO       Port3 TX
 26   PIO       Port3 RS485TXRX
 27   PIO       Port3 RS485TXEnable
 28   GPIO/IRQ  nFL (Motor fault) needs pull up
 29   ADC       ADC_VIN = (vin*10/(10+47))

To get Picoprobe to work with udev rule some combination of the following
works.

root@ear:/etc/udev/rules.d# cat 99-picoprobe.rules
# Picoprobe
# ATTRS{idVendor}=="2E8A", ATTRS{idProduct}=="0004", MODE="0666", OWNER="mo", GROUP="mo"
# ATTRS{idVendor}=="2e8a", ATTRS{idProduct}=="0004", MODE="660", GROUP="plugdev", TAG+="uaccess"
ATTRS{idVendor}=="2e8a", ATTRS{idProduct}=="0004", MODE="660", GROUP="plugdev"

root@ear:/etc/udev/rules.d# /etc/init.d/udev restart
root@ear:/etc/udev/rules.d# udevadm control --reload

Built openocd branch with modified Makefile:
  prefix = /home/mo/tempd/pico/openocd/usr/local
instead of
  prefix = /usr/local

Then can make install as non-root and not write over other modified version
of openocd we already have in /usr/local.

Now (as non-root) can do

/home/mo/tempd/pico/openocd/usr/local/bin/openocd -f /home/mo/tempd/pico/openocd/usr/local/share/openocd/scripts/interface/picoprobe.cfg -f /home/mo/tempd/pico/openocd/usr/local/share/openocd/scripts/target/rp2040.cfg -s tcl

For bootloader:
  Standard linker scripts are in pico-sdk/src/rp2_common/pico_standard_link
  Looks like we can override using a CMAKEism. From pico-sdk/src/rp2_common/pico_standard_link/CMakeLists.txt :
    # LINKER script will be PICO_TARGET_LINKER_SCRIPT if set on target, or ${CMAKE_CURRENT_LIST_DIR}/memmap_foo.ld

export PICO_SDK_PATH=/home/mo/tempd/pico/pico-sdk/


TODO
Fix GPIO drive strengths
Test ID margins
Think about PID control variable from combi mode, alignment problems in device_varfrommode
Make <selvar> just have values 0, 1, 2, 3 (i.e., only signed char/short/int plus float)

I²C commands:

Initialisation :

 # Addr Data Function
 1 0x5C 0x20 Set PWM0 Period CLK to OSC1 Flex-Div
 2 0x5D 0x03 Set OSC1 Flex-Div to 4
 3 0x9D 0x0E Set 2-bit LUT2 Logic to OR
 4 0x19 0x7A Connection 2-bit LUT2 IN1 to I2C OUT7  Connection 2-bit LUT2 IN0 to PWM0 OUT+
 5 0x1A 0x06
 6 0x09 0x03 Connection HV OUT CTRL0 EN Input to 2-bit LUT2 OUT
 7 0x0C 0x03 Connection HV OUT CTRL1 EN Input to 2-bit LUT2 OUT
 8 0x3C 0x16 Connection PWM0 PWR DOWN Input to 3-bit LUT9 OUT
 9 0xB6 0x09 Set PWM0 to flex-Div clock
10 0x4C 0x70 Clear fault flags
11 0x4C 0x7F Enable fault flags

For changing Duty Cycle:

 # Address, hex Data, hex Function
 1 0xA1 0x00 to 0xFF Set PWM0 Initial Duty Cycle value [7:0]. Default: 0x00
 2 0xA2 0x01 Set I2C trigger for PWM0 to Update duty cycle value

The your using the old 10bit design with the period reduce by a quarter (
0x86, 0x3f write ) to give 8 bits

so in port init add the follow I2c write address 0x59 = 0x2A

> You could try setting 0xB6 to 0x19, you may need to set 0x5D to 0x1 to get
> the PWM frequency back up. 


LED Matrix
==========

Connect it up and enable power - the polarity doesn't seem to matter
for this device. Then use a DATA command (not a WRITE command as the
documentation suggests) as follows:

  select 0
  write1 c0 5

and you should get one row of fully-lit green LEDs and one partially-lit
row. The value "5" can be from 0 to 9, giving you 0-3 rows of LEDs lit
with interpolation. If you are typing these by hand you can abbreviate
"write1" to "w".

If you do

  select 1
  write1 c1 1

everything lights red;

  write1 c1 2

everything lights magenta; 3=blue, 4=cyan, 5=pale green, 6=green,
7=yellow, 8=orange, 9=red, 0a=white... and lots more colours
that don't appear to be in a logical order. (According to the MODE
data it only goes up to 0x0a, so maybe it is reading off the end of a
table in ROM!)

The most flexible mode is mode 2.

  select 2
  write1 c2 12 23 34 45 12 23 34 45 12

gives a random pattern of dull colours

  write1 c2 67 72 78 82 89 92 9a a4 aa

gives some random bright ones. 0xaa is the highest colour number but
again higher numbers do do something. The first hex digit seems to be
the brightness and the second hex digit the basic colour: compare

  write1 c2 1a 2a 3a 4a 5a 6a 7a 8a 9a

(shades of white) and

  write1 c2 a1 a2 a3 a4 a5 a6 a7 a8 a9

(all the basic colours at full brightness).

Mode 3 (TRANS) controls transitions. If you do

  write1 c3 1

you get a row-by-row animated transition from one state to the
next;

  write1 c3 2

does a fade to black and fade back up. You can get some bizarre flashing
effects by fading through non-existent colours (above 0xaa), which may
or may not be deliberate.

Note that mode 2 reads out with the data in row-reversed order.

Colour sensor
=============

Power it backwards. In other words, you have to do

  plimit 1   <- to allow full power
  set -1     <- power up with negative polarity

then

  select 0

and you will get some numbers - looks like they are colour indices.

  select 1

gives you something like distance, or it may be reflected intensity.

I'm fairly sure I tried this on the ultrasound sensor too and it
didn't work. But now it seems to. I have plugged both these
devices into the Spike hub since then, and I am wondering if
it has uploaded some code into the device.

Ultrasound sensor
=================

  Power it up backwards:

  plimit 1
  set -1

Then select the LIGHT mode:

  select 5

and now you can write 4 bytes as follows:

  write1 c5 pp qq rr ss

which will light up the LEDs. With the LEGO logo the right way up and
from the robot's point of view the values are:

  pp=right-eye-upper
  qq=left-eye-upper
  rr=right-eye-lower
  ss=left-eye-lower

and the numbers can range from 0 to 64 hex (100 decimal). You can
only get white AFAICT.



>>> m.run_to_position(180,100)
port 0 ; selonce 0
port 0 ; selonce 0
 pos 140300 apos 25
 diff 155
 newpos 390.15277777777777
port 0 ; combi 0 1 0 2 0 3 0 ; select 0 ; pid 0 0 1 s4 0.0027777778 0 5 0 .1 3
set ramp 389.72222222222223 390.15277777777777 0.08611111111110858 0
port 0 ; coast

Then spins forever:
>>> m.run_to_position(0,100)
port 0 ; selonce 0
port 0 ; selonce 0
 pos 140455 apos -180
 diff -180
 newpos 389.65277777777777
port 0 ; combi 0 1 0 2 0 3 0 ; select 0 ; pid 0 0 1 s4 0.0027777778 0 5 0 .1 3
set ramp 390.15277777777777 389.65277777777777 0.1 0

set ramp 0 1 1 0
coast

combi 0 1 0 2 0 3 0 ; select 0 ; pid 0 0 1 s4 0.0027777778 0 5 0 .1 3
coast
set ramp 1 2 1 0
coast
set ramp 2 1 1 0

Changes in PID_experimental
===========================

Mandatory "deadzone" PID parameter

